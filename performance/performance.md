# Performance
This section will cover the basics on configuring services for performance with WordPress.

## Caching
WordPress has a lot of dynamic functionality, but this comes at a cost. Tasks such as processing PHP, querying the database and collecting information from external APIs all take resources and time. 

> Caching saves time for potentially heavy tasks by reusing previously computed results, rather than calculating them for every page view. 

Caches typically expire after a certain amount of time and are regenerated so the most recent content is displayed. When items are served from cache they have a faster response time, often coming from memory, and take load off the server.

In a typical page load, various caches might be checked in the following order:

1. Local Browser cache / Local Storage / Web App Manifest
2. [Content Delivery Network (CDN)](#Content-Distribution-Network-CDN-Cache)
3. [Full Page Cache](#Full-Page-Cache) (Reverse Proxy; RAM or SSD with Nginx+)
4. [Full Page Cache](#Full-Page-Cache) (Static; PHP)
5. [Opcode Cache](#Opcode-Cache)
6. [Object Cache](#Object-Cache) (wp_options, transient API)
7. [Fragment Cache](#Fragment-Cache) (Database, static files, transient API)
8. Transients API (Object Cache or Database Cache)
9. Database Cache
10. File Storage Cache (Static Files, SSD or spinning disk)

Each caching instance may be a different domain, server, or compute instance, either routed by the local machine, the remote server cluster, or any intermediary computer along the request chain.

Each cache may have any configuration of:
Data storage: RAM, SSD, or spinning hard drives. Physical connection, or data over network.
Input/Output latency: Connection from local or remote server motherboard to RAM, Data I/O, or network I/O.

For any given page load, speed and user experience will result from the combined latency of all services, and the order they are processed as users interact with a web application.

(**Example**: CSS; Generated by JavaScript, PHP or pre-processor. Sent over network. Earliest display: Inline script within first HTTP packet of first HTML response. Typical: Loaded by many plugins in many files over many requests. Middle-ground: combined file, cached locally, to CDN, or server RAM or SSD.)


### Content Distribution Network (CDN) Cache
Content distribution networks are designed to optimize the network latency between servers and visitors from different geographical locations. Data is distributed amongst endpoints and then visitors get served from the endpoint which is closest to them. 

In addition to optimizing networking latency, CDNs can act as another layer of static and/or full-page caching running on all those endpoints. 

It’s important to make sure that CDNs are working well with all your other caching systems and that it purges caches on all endpoints when you request that from your main server. Otherwise, people in certain areas may get old results which is generally an issue that’s difficult to troubleshoot.


### Full Page Cache
In order to display your content, WordPress does a lot of work under the hood, and all those calculations require server resources and time to complete. For starters, the PHP service on the server has to process the request, load WordPress core, your theme PHP files and all PHP scripts coming from your plugins. The majority of those PHP files make requests to your database, too, which adds to the overall resource footprint of your site. 

The best way to cache these requests is to use a reverse proxy like NGINX or Varnish which stores the output directly into the server memory That saves a lot of processing power because cached content is served straight out of the reverse proxy without hitting your web server, the PHP service or your database service at all. If such technology is not available on your current server setup, you can fallback to storing cached content into your file system. It's slower than reverse proxies and a hit reaches your web server and your PHP service at least once, so it can direct the request to the proper cached file but still - it's much faster than doing all the computing for every request. 

Full Page Caching stores the HTML output of a request, but all the CSS, JS, images and font files will have to be loaded separately too. They are handled separately and optimizing them is worth investing the time and effort. Static caching can have great effect on those resources. You can often use the same reverse proxy to  static resources in the server memory - CSS, JS, Fonts, Images and serve them directly.

Note that it's important to be able to expire caches when necessary, otherwise you can serve visitors old data. Furthermore, it's good practice to exclude certain types of pages from your full page caching completely because they are different for each user. For example, if you have an 
online store it's imperative that your cart, checkout and profile pages are completely dynamic. In general, it’s a good idea to exclude all logged in users from the cache because they are supposed to see personalized content. Another important aspect is the default caching period which can be different for each website depending on how often data is changed. 

![Full Page Caching Response Example](/assets/full-page-caching-response-example.png)

### Object Cache
> In 2005, WordPress introduced its internal object cache — a way of automatically storing any data from the database (not just objects) in PHP memory to prevent unnecessary queries. However, out of the box, WordPress will discard all of those objects at the end of the request, requiring them to be rebuilt from scratch for the next page load.

###### source: [scalewp.io](https://www.scalewp.io/object-caching/)

What does this mean? Think of a standard WordPress homepage displaying the most recent posts. Each of these posts has quite a bit of information associated with it WordPress must look up such as the author, categories, tags, and excerpt.

Support for a persistent object cache gives WordPress, plugins, and themes, a place to store that data for reuse. While these items are cached, PHP execution time is improved while lessening the load on the database. It's particularly helpful in situations where much of the page is difficult to cache from the front-end, like for authenticated traffic or e-commerce applications.

For these reasons, persistent object caching support is commonly offered with Managed WordPress hosting.

![WordPress Object Caching Diagram](/assets/wordpress-object-caching-example.png)

> Transients are inherently sped up by caching plugins, where normal Options are not. A memcached plugin, for example, would make WordPress store transient values in fast memory instead of in the database. For this reason, transients should be used to store any data that is expected to expire, or which can expire at any time. Transients should also never be assumed to be in the database, since they may not be stored there at all.

###### source: [WordPress Codex](https://codex.wordpress.org/Transients_API)

**TODO: Consider talking about autoload and Memcached**

### Opcode Cache
As mentioned in the section on full page caching, WordPress processes PHP scripts as part of producing the HTML, CSS and JavaScript for a browser to load. It takes time for the web server to read each PHP script WordPress needs, to compile the script and to run it. By default, PHP recompiles these scripts for each request made. Full page caching can reduce how much the web server has to do this depending on what kind of full page caching is used, but the original pages still need to be generated. For example, WordPress caching plugins still have to check if they need to rebuild their caches. PHP scripts also have to be read, compiled, and run for WordPress to generate any dynamic, uncached content like comments or the page for a WooCommerce store and for WordPress to show the admin dashboard. Using opcode caching can help speed up your server since it can run WordPress without having to read and compile PHP scripts for every single page visit.

Opcode caching stores a compiled copy of every PHP script in memory or on disk. When the web server starts processing PHP scripts for WordPress, the web server checks the opcode cache for a cached copy of the PHP script. If there is a cached copy, the web server can skip straight to running the PHP script using the cached copy instead of having to read and compile the script again. Skipping this reading and compiling PHP scripts can greatly improve the web server's resource usage and enable WordPress to serve many more requests than it might have been able to otherwise.

Opcode caching can help web servers use fewer resources when running WordPress; however, like with full page caching, opcode caching can cause changes to WordPress, such as installing or removing plugins and themes or updating WordPress, from showing up right away. It can be useful to manually purge the opcode cache after making any changes to the PHP files that make up WordPress.

### Fragment Cache
This caching method allows saving sections of otherwise non-cacheable dynamic website content. It can help especially for sites where the majority of the page is static, but has certain dynamic elements, like a shopping cart, or for membership sites.

In the WordPress context, developers often store parts of the page using the WordPress transients/object cache API. In these cases, providing a persistent object cache will allow that caching to happen outside of the database.

Storing these fragments separately in a front end cache is not natively supported by WordPress, and means both manually configuring the sections of the page to be cached, and configuring your front-end cache, whether it be Nginx, Varnish, or otherwise, to support fragment caching. This is usually an advanced technique, and reserved for sites or hosting platforms with very high dynamic traffic needs.

## Purging / Busting / Clearing Caches
Purging caches is as important as storing them. You have to make sure that all layers of caching are cleared when necessary.

There are several layers of caches that you should consider:

Server Caches - full page cache, object caching, static caching is stored on the main site server.

CDN Caches - those usually copy the server caches but are stored on the CDN’s endpoints so you have to make sure they are cleared when server cache is purged.

Browser Caches - modern browsers store locally a lot of information in order to render sites faster - usually CSS, JS, Fonts, Images are stored on your visitors computers and unless expired loaded from there. You have to make sure that you notify  visitors browsers that certain resource has been updated so they don’t load old versions of it. That’s usually done with heathers and eTags explained below.


## PHP

PHP (PHP: Hypertext Preprocessor) is a popular programming language on the internet. PHP turns dynamic content, like that in WordPress, into HTML, CSS, and JavaScript that web browsers can read. WordPress is written primarily in PHP, and a server must have PHP in order for WordPress to be able to run.

As PHP is an interpreted language, its version and configuration has a large impact on how well and whether WordPress will run.

### Version

When possible, PHP 7.x should be used to run WordPress. As of the writing of this document, PHP 7 is the only major version of PHP still receiving active development and support. The PHP group regularly retires support for older versions of PHP, and older versions are not guaranteed to be updated for security concerns. At the same time, newer versions of PHP contain both security and performance improvements, while being accompanied by new features and bug fixes, which are not guaranteed to be backwards compatible. However, extreme care must be taken when upgrading the version of PHP. While WordPress is compatible with the latest releases of PHP, sites built to use older versions of PHP may not be compatible due to their included plugins and themes. 

If upgrading to PHP 7 is not immediately possible, upgrading to PHP 5.6 should be done as soon as possible. PHP 5.6 is the oldest version of PHP 5 that is still receiving security patches. Older versions of PHP are not having their bugs and vulnerabilities patched and should be considered insecure and avoided.

More information about the support versions of PHP can always be found [on PHP's supported versions page](http://php.net/supported-versions.php)

A good approach is to test a website for compatibility with PHP7 before upgrading. You can use a [WP-CLI command](https://github.com/danielbachhuber/php-compat-command) for that purpose and make sure all used plugins and the active theme will work fine.

### Configuration
PHP is primarily configured using a configuration file, `php.ini`, from which PHP reads all of its settings and configuration at runtime, whether through CGI/FastCGI, or a process manager like PHP-FPM.

#### Timeouts
PHP has several timeout settings that limit the time different aspects of the rendering process - maximum execution time, upload file size, etc. It is important that you select those carefully in compliance with other limitations that you have on your web server. When configuring your timeouts, it's important to select values that work well together. For example, it doesn't make sense to have a very high script execution timeout on your PHP service, if the Apache timeout is lower than that - in such case, if the request takes longer, it will be killed by the web server no matter your PHP timeout setting. 

Note, that processes take different amount of time, depending on the server load and those limitations are placed to ensure that your server functions properly. If you have high server load, processes may take longer to complete thus causing a cascade effect leading to even more server load. That's why it's a matter of balance between giving enough time for your scripts to be compiled and ensuring that you're within normal server loads.

#### Memory Limits
WordPress requires server memory to operate properly. It has two main values that define the amount of memory the application is allowed to use which are stored in the **wp-config.php** file:

```
define('WP_MEMORY_LIMIT', '128M');
```
This option declares the amount of memory WordPress can use for rendering the front end of the website.

```
define( 'WP_MAX_MEMORY_LIMIT', '256M' );
```
Since the WordPress backend usually requires more memory, there's a separate setting for the amount, that can be set for logged in users. This is mainly required for image uploads. You can have that higher than the front end limit to ensure your backend has all the resources it needs.

WordPress will attempt to raise the PHP `memory_limit` to the specified values above if it has permission to do so.


#### File Upload Sizes
When uploading media files and other content to WordPress using the WordPress admin dashboard, WordPress uses PHP to process the uploads. PHP's configuration includes limits on the size of files that can be uploaded through PHP and on the size of requests that can be sent to the web server for processing. You need to match those with your existing processing timeouts.

The limit on the size of individual files can be configured using the `upload_max_filesize` `php.ini` directive.
```
upload_max_filesize = 8M
```
The limit on the size of requests that can be sent to the web server for processing can be configured using the post_max_size php.ini directive. 8 megabytes is the default value for post_max_size if no value for `post_max_size` is defined in the php.ini file in use for the WordPress website.
```
post_max_size = 8M
```
The value for `post_max_size` must be greater than or equal to the value for `upload_max_filesize`. PHP will not process requests larger in size than the value for `post_max_size`.

Note, that `post_max_size` applies to every PHP request and not only uploads. Usually for regular requests it’s enough but you may want to check it if large amount of data is transmitted through PHP.

#### Replacing WordPress' Cron Triggers
The `wp-cron.php` is responsible for causing certain tasks to be scheduled and executed automatically. Every time someone visits your website, `wp-cron.php` checks whether it is time to execute a job or not. Even though these checks are small and fast they consume time and produce load. For this reason, it's worth considering setting the `DISABLE_WP_CRON` constant and considering using an alternative method to trigger WordPress' cron system.
